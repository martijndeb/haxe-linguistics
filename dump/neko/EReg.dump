class EReg{
	public new(method) : r : String -> opt : String -> Void

	 = function(r:String,opt:String) = {
		var a = opt.split("g");
		this.global = a.length > 1;
		if ((this.global))opt = a.join(""));
		this.r = EReg.regexp_new_options(r.__s,opt.__s);
	};

	r(var) : Dynamic;

	global(var) : Bool;

	public split(method) : s : String -> Array<String>

	 = function(s:String) = {
		var pos = 0;
		var len = s.length;
		var a = new Array();
		var first = true;
		do ({
			if ((! EReg.regexp_match(this.r,s.__s,pos,len)))break);
			var p = EReg.regexp_matched_pos(this.r,0);
			if ((p.len == 0 && ! first)){
				if ((p.pos == s.length))break);
				p.pos += 1;
			});
			a.push(s.substr(pos,p.pos - pos));
			var tot = p.pos + p.len - pos;
			pos += tot;
			len -= tot;
			first = false;
		}) while((this.global));
		a.push(s.substr(pos,len));
		return a;
	};

	static regexp_new_options(var) : Unknown<1> -> Unknown<2> -> Unknown<0>

	 = neko.Lib.load("regexp","regexp_new_options",2);

	static regexp_match(var) : Dynamic -> Unknown<3> -> Int -> Int -> Bool

	 = neko.Lib.load("regexp","regexp_match",4);

	static regexp_matched_pos(var) : Dynamic -> Int -> { pos : Int, len : Int }

	 = neko.Lib.load("regexp","regexp_matched_pos",2);

}